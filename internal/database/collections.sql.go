// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: collections.sql

package database

import (
	"context"
	"database/sql"
)

const createCollectionItem = `-- name: CreateCollectionItem :one
INSERT INTO collections (filename, collection_name,  content, metadata)
VALUES (?, ?, ?, ?)
RETURNING filename, collection_name, content, metadata, created_at
`

type CreateCollectionItemParams struct {
	Filename       string
	CollectionName string
	Content        string
	Metadata       string
}

type CreateCollectionItemRow struct {
	Filename       string
	CollectionName string
	Content        string
	Metadata       string
	CreatedAt      sql.NullString
}

func (q *Queries) CreateCollectionItem(ctx context.Context, db DBTX, arg CreateCollectionItemParams) (CreateCollectionItemRow, error) {
	row := db.QueryRowContext(ctx, createCollectionItem,
		arg.Filename,
		arg.CollectionName,
		arg.Content,
		arg.Metadata,
	)
	var i CreateCollectionItemRow
	err := row.Scan(
		&i.Filename,
		&i.CollectionName,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCollectionItem = `-- name: DeleteCollectionItem :exec
DELETE FROM collections
WHERE filename = ? AND collection_name = ?
`

type DeleteCollectionItemParams struct {
	Filename       string
	CollectionName string
}

func (q *Queries) DeleteCollectionItem(ctx context.Context, db DBTX, arg DeleteCollectionItemParams) error {
	_, err := db.ExecContext(ctx, deleteCollectionItem, arg.Filename, arg.CollectionName)
	return err
}

const getCollectionItem = `-- name: GetCollectionItem :one
SELECT filename, collection_name, content, metadata, created_at
FROM collections
WHERE filename = ? AND collection_name = ?
`

type GetCollectionItemParams struct {
	Filename       string
	CollectionName string
}

type GetCollectionItemRow struct {
	Filename       string
	CollectionName string
	Content        string
	Metadata       string
	CreatedAt      sql.NullString
}

func (q *Queries) GetCollectionItem(ctx context.Context, db DBTX, arg GetCollectionItemParams) (GetCollectionItemRow, error) {
	row := db.QueryRowContext(ctx, getCollectionItem, arg.Filename, arg.CollectionName)
	var i GetCollectionItemRow
	err := row.Scan(
		&i.Filename,
		&i.CollectionName,
		&i.Content,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const listAllCollectionItems = `-- name: ListAllCollectionItems :many
SELECT filename, content, metadata, created_at
FROM collections
WHERE collection_name = ?
ORDER BY created_at DESC
`

type ListAllCollectionItemsRow struct {
	Filename  string
	Content   string
	Metadata  string
	CreatedAt sql.NullString
}

func (q *Queries) ListAllCollectionItems(ctx context.Context, db DBTX, collectionName string) ([]ListAllCollectionItemsRow, error) {
	rows, err := db.QueryContext(ctx, listAllCollectionItems, collectionName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllCollectionItemsRow
	for rows.Next() {
		var i ListAllCollectionItemsRow
		if err := rows.Scan(
			&i.Filename,
			&i.Content,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCollectionItem = `-- name: UpdateCollectionItem :exec
UPDATE collections
SET content = ?, metadata = ?
WHERE filename = ? AND collection_name = ?
`

type UpdateCollectionItemParams struct {
	Content        string
	Metadata       string
	Filename       string
	CollectionName string
}

func (q *Queries) UpdateCollectionItem(ctx context.Context, db DBTX, arg UpdateCollectionItemParams) error {
	_, err := db.ExecContext(ctx, updateCollectionItem,
		arg.Content,
		arg.Metadata,
		arg.Filename,
		arg.CollectionName,
	)
	return err
}
